{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "339945a3-182f-4b6c-b544-7038fc15099a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "        <iframe\n",
       "            width=\"100%\"\n",
       "            height=\"650\"\n",
       "            src=\"http://127.0.0.1:8050/\"\n",
       "            frameborder=\"0\"\n",
       "            allowfullscreen\n",
       "            \n",
       "        ></iframe>\n",
       "        "
      ],
      "text/plain": [
       "<IPython.lib.display.IFrame at 0x26c4fd58740>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import plotly.express as px\n",
    "from datetime import timedelta\n",
    "from dash import Dash, dcc, html, Input, Output, State, callback_context\n",
    "from sklearn.linear_model import Ridge\n",
    "\n",
    "# -----------------------------\n",
    "# Config\n",
    "# -----------------------------\n",
    "DATA_PATH = r\"C:\\Users\\shyamsunder\\OneDrive\\Documents\\pranjal sir\\us_supermarket.csv\"   # relative to this script\n",
    "\n",
    "# -----------------------------\n",
    "# Load & clean\n",
    "# -----------------------------\n",
    "raw = pd.read_csv(DATA_PATH, encoding=\"latin-1\")\n",
    "\n",
    "# Normalize column names for safety\n",
    "raw.columns = [c.strip().replace(\" \", \"_\") for c in raw.columns]\n",
    "\n",
    "# Pick (robust to common Superstore schemas)\n",
    "date_col_candidates = [\"Order_Date\", \"Date\"]\n",
    "for c in date_col_candidates:\n",
    "    if c in raw.columns:\n",
    "        date_col = c\n",
    "        break\n",
    "else:\n",
    "    raise ValueError(\"Order Date column not found. Expected one of: 'Order Date' or 'Date'.\")\n",
    "\n",
    "raw[date_col] = pd.to_datetime(raw[date_col], errors=\"coerce\")\n",
    "raw = raw.dropna(subset=[date_col])\n",
    "\n",
    "# Basic derived fields\n",
    "raw[\"Sales\"] = pd.to_numeric(raw.get(\"Sales\", 0), errors=\"coerce\").fillna(0.0)\n",
    "raw[\"City\"] = raw.get(\"City\", \"Unknown\").astype(str)\n",
    "raw[\"Region\"] = raw.get(\"Region\", \"Unknown\").astype(str)\n",
    "raw[\"Category\"] = raw.get(\"Category\", \"Unknown\").astype(str)\n",
    "raw[\"Sub-Category\"] = raw.get(\"Sub-Category\", raw.get(\"Sub_Category\", \"Unknown\")).astype(str)\n",
    "\n",
    "# Optional fields\n",
    "payment_col = \"Payment\" if \"Payment\" in raw.columns else None\n",
    "\n",
    "# Create a new Date column first\n",
    "raw[\"Date\"] = raw[date_col].dt.date\n",
    "\n",
    "# Group by that new column\n",
    "daily = raw.groupby(\"Date\", as_index=False)[\"Sales\"].sum()\n",
    "\n",
    "# Ensure it's datetime type\n",
    "daily[\"Date\"] = pd.to_datetime(daily[\"Date\"])\n",
    "\n",
    "# -----------------------------\n",
    "# Forecast (next 30 days) via simple regression\n",
    "# -----------------------------\n",
    "def add_time_features(df, date_col=\"Date\"):\n",
    "    out = df.copy()\n",
    "    out[\"t\"] = (out[date_col] - out[date_col].min()).dt.days\n",
    "    out[\"dow\"] = out[date_col].dt.dayofweek\n",
    "    out[\"month\"] = out[date_col].dt.month\n",
    "    # cyclic encodings\n",
    "    out[\"dow_sin\"] = np.sin(2*np.pi*out[\"dow\"]/7)\n",
    "    out[\"dow_cos\"] = np.cos(2*np.pi*out[\"dow\"]/7)\n",
    "    out[\"mon_sin\"] = np.sin(2*np.pi*out[\"month\"]/12)\n",
    "    out[\"mon_cos\"] = np.cos(2*np.pi*out[\"month\"]/12)\n",
    "    return out\n",
    "\n",
    "# Train model\n",
    "features = [\"t\", \"dow_sin\", \"dow_cos\", \"mon_sin\", \"mon_cos\"]\n",
    "dtrain = add_time_features(daily, \"Date\").dropna(subset=[\"Sales\"])\n",
    "\n",
    "model = Ridge(alpha=1.0)\n",
    "model.fit(dtrain[features], dtrain[\"Sales\"])\n",
    "\n",
    "# Predict future horizon\n",
    "horizon = 30\n",
    "last_date = dtrain[\"Date\"].max()\n",
    "future_dates = pd.date_range(last_date + timedelta(days=1), periods=horizon, freq=\"D\")\n",
    "future_df = pd.DataFrame({\"Date\": future_dates})\n",
    "future_feat = add_time_features(future_df, \"Date\")\n",
    "future_df[\"Predicted_Sales\"] = model.predict(future_feat[features])\n",
    "\n",
    "# -----------------------------\n",
    "# Dash App\n",
    "# -----------------------------\n",
    "app = Dash(__name__)\n",
    "app.title = \"US Supermarket — Descriptive & Predictive Dashboard\"\n",
    "\n",
    "# UI Controls\n",
    "cities = sorted(raw[\"City\"].dropna().unique().tolist())\n",
    "products = sorted(raw[\"Sub-Category\"].dropna().unique().tolist())\n",
    "\n",
    "app.layout = html.Div([\n",
    "    html.H2(\"US Supermarket Sales — Descriptive & Predictive Dashboard\", className=\"title\"),\n",
    "\n",
    "    html.Div([\n",
    "        dcc.DatePickerRange(\n",
    "            id=\"date-range\",\n",
    "            min_date_allowed=daily[\"Date\"].min(),\n",
    "            max_date_allowed=daily[\"Date\"].max(),\n",
    "            start_date=daily[\"Date\"].min(),\n",
    "            end_date=daily[\"Date\"].max(),\n",
    "            display_format=\"YYYY-MM-DD\",\n",
    "        ),\n",
    "        dcc.Dropdown(options=[{\"label\": c, \"value\": c} for c in cities],\n",
    "                     multi=True, id=\"city-dd\", placeholder=\"Filter by City\"),\n",
    "        dcc.Dropdown(options=[{\"label\": p, \"value\": p} for p in products],\n",
    "                     multi=True, id=\"prod-dd\", placeholder=\"Filter by Sub-Category\"),\n",
    "        dcc.Store(id=\"filters\", data={\"cities\": [], \"products\": [], \"date\": None})\n",
    "    ], style={\"display\": \"grid\", \"gridTemplateColumns\": \"1fr 1fr 1fr\", \"gap\": \"12px\", \"marginBottom\": \"10px\"}),\n",
    "\n",
    "    html.Div([\n",
    "        dcc.Graph(id=\"g_trend\", config={\"displayModeBar\": True}),\n",
    "    ], style={\"marginBottom\": \"10px\"}),\n",
    "\n",
    "    html.Div([\n",
    "        dcc.Graph(id=\"g_product\", config={\"displayModeBar\": True}),\n",
    "        dcc.Graph(id=\"g_city\", config={\"displayModeBar\": True}),\n",
    "        dcc.Graph(id=\"g_dist\", config={\"displayModeBar\": True}),\n",
    "    ], style={\"display\": \"grid\", \"gridTemplateColumns\": \"1fr 1fr 1fr\", \"gap\": \"10px\"}),\n",
    "\n",
    "    html.Div([\n",
    "        dcc.Graph(id=\"g_forecast\", config={\"displayModeBar\": True})\n",
    "    ])\n",
    "], style={\"fontFamily\": \"sans-serif\", \"padding\": \"12px\"})\n",
    "\n",
    "# -----------------------------\n",
    "# Helpers\n",
    "# -----------------------------\n",
    "def apply_filters(df, start_date, end_date, cities_sel, prods_sel):\n",
    "    dff = df.copy()\n",
    "    if start_date:\n",
    "        dff = dff[dff[date_col] >= pd.to_datetime(start_date)]\n",
    "    if end_date:\n",
    "        dff = dff[dff[date_col] <= pd.to_datetime(end_date)]\n",
    "    if cities_sel:\n",
    "        dff = dff[dff[\"City\"].isin(cities_sel)]\n",
    "    if prods_sel:\n",
    "        dff = dff[dff[\"Sub-Category\"].isin(prods_sel)]\n",
    "    return dff\n",
    "\n",
    "# -----------------------------\n",
    "# Main update: render all descriptive charts given current filters\n",
    "# -----------------------------\n",
    "@app.callback(\n",
    "    [Output(\"g_trend\", \"figure\"),\n",
    "     Output(\"g_product\", \"figure\"),\n",
    "     Output(\"g_city\", \"figure\"),\n",
    "     Output(\"g_dist\", \"figure\")],\n",
    "    [Input(\"date-range\", \"start_date\"),\n",
    "     Input(\"date-range\", \"end_date\"),\n",
    "     Input(\"city-dd\", \"value\"),\n",
    "     Input(\"prod-dd\", \"value\"),\n",
    "     Input(\"g_trend\", \"clickData\"),\n",
    "     Input(\"g_product\", \"clickData\"),\n",
    "     Input(\"g_city\", \"clickData\")]\n",
    ")\n",
    "def render_descriptive(sdate, edate, cities_sel, prods_sel, trend_click, prod_click, city_click):\n",
    "    # Determine if a chart interaction should refine filters\n",
    "    ctx = callback_context\n",
    "    trigger = ctx.triggered[0][\"prop_id\"].split(\".\")[0] if ctx.triggered else None\n",
    "\n",
    "    # Start with dropdown/date filters\n",
    "    cities_final = cities_sel or []\n",
    "    prods_final = prods_sel or []\n",
    "\n",
    "    # Apply chart clicks as additional filters\n",
    "    local_start, local_end = sdate, edate\n",
    "    if trigger == \"g_trend\" and trend_click:\n",
    "        # clicked x is a date string\n",
    "        local_start = local_end = trend_click[\"points\"][0][\"x\"]\n",
    "    if trigger == \"g_product\" and prod_click:\n",
    "        p = prod_click[\"points\"][0][\"x\"]\n",
    "        prods_final = list(set(prods_final + [p]))\n",
    "    if trigger == \"g_city\" and city_click:\n",
    "        c = city_click[\"points\"][0][\"x\"]\n",
    "        cities_final = list(set(cities_final + [c]))\n",
    "\n",
    "    dff = apply_filters(raw, local_start, local_end, cities_final, prods_final)\n",
    "    \n",
    "       # Create Date column\n",
    "    dff[\"Date\"] = dff[date_col].dt.date\n",
    "    \n",
    "    # Group by Date\n",
    "    trend_df = dff.groupby(\"Date\", as_index=False)[\"Sales\"].sum()\n",
    "    \n",
    "    # Convert Date column to datetime\n",
    "    trend_df[\"Date\"] = pd.to_datetime(trend_df[\"Date\"])\n",
    "    \n",
    "    # Plot\n",
    "    fig_trend = px.line(trend_df, x=\"Date\", y=\"Sales\", title=\"Daily Sales Trend\")\n",
    "\n",
    "    # Product (Bar) — by Sub-Category\n",
    "    prod_df = dff.groupby(\"Sub-Category\", as_index=False)[\"Sales\"].sum().sort_values(\"Sales\", ascending=False).head(15)\n",
    "    fig_product = px.bar(prod_df, x=\"Sub-Category\", y=\"Sales\", title=\"Sales by Sub-Category\")\n",
    "\n",
    "    # City (Bar)\n",
    "    city_df = dff.groupby(\"City\", as_index=False)[\"Sales\"].sum().sort_values(\"Sales\", ascending=False).head(15)\n",
    "    fig_city = px.bar(city_df, x=\"City\", y=\"Sales\", title=\"Sales by City\")\n",
    "\n",
    "    # Distribution (Pie if Payment exists, else Histogram of Discount)\n",
    "    if \"{}\".format(payment_col) != \"None\" and payment_col in raw.columns:\n",
    "        pay_df = dff.groupby(payment_col, as_index=False)[\"Sales\"].sum()\n",
    "        fig_dist = px.pie(pay_df, names=payment_col, values=\"Sales\", title=\"Sales by Payment Method\")\n",
    "    else:\n",
    "        hist_df = dff.copy()\n",
    "        hist_df[\"Discount\"] = pd.to_numeric(hist_df.get(\"Discount\", 0), errors=\"coerce\").fillna(0)\n",
    "        fig_dist = px.histogram(hist_df, x=\"Discount\", nbins=30, title=\"Discount Distribution\")\n",
    "\n",
    "    return fig_trend, fig_product, fig_city, fig_dist\n",
    "\n",
    "# -----------------------------\n",
    "# Forecast chart (static trained model, always shown)\n",
    "# -----------------------------\n",
    "@app.callback(\n",
    "    Output(\"g_forecast\", \"figure\"),\n",
    "    [Input(\"date-range\", \"start_date\"),\n",
    "     Input(\"date-range\", \"end_date\"),\n",
    "     Input(\"city-dd\", \"value\"),\n",
    "     Input(\"prod-dd\", \"value\")]\n",
    ")\n",
    "def render_forecast(sdate, edate, cities_sel, prods_sel):\n",
    "    # Forecast is based on the full historical daily totals (model already trained).\n",
    "    # We simply display historical plus next 30 days prediction.\n",
    "    hist = daily.copy()\n",
    "    hist = hist[(hist[\"Date\"] >= pd.to_datetime(sdate)) & (hist[\"Date\"] <= pd.to_datetime(edate))] if sdate and edate else hist\n",
    "\n",
    "    hist[\"Type\"] = \"Actual\"\n",
    "    fc = future_df.rename(columns={\"Predicted_Sales\": \"Sales\"}).copy()\n",
    "    fc[\"Type\"] = \"Forecast\"\n",
    "\n",
    "    combined = pd.concat([hist[[\"Date\", \"Sales\", \"Type\"]], fc[[\"Date\", \"Sales\", \"Type\"]]], ignore_index=True)\n",
    "\n",
    "    fig_fc = px.line(combined, x=\"Date\", y=\"Sales\", color=\"Type\", title=\"Sales Forecast (Next 30 Days)\")\n",
    "    return fig_fc\n",
    "\n",
    "# -----------------------------\n",
    "# Run\n",
    "# -----------------------------\n",
    "if __name__ == \"__main__\":\n",
    "    app.run(debug=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d9f592c8-0c0f-4c59-af92-603fbd51a39c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
